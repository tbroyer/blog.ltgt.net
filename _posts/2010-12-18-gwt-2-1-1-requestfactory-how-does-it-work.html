---
layout: post
title: GWT 2.1.1 RequestFactory â€“ How does it work?
published: false
---
<p>GWT 2.1.1 has just been released, and it contains a new <a href="http://code.google.com/webtoolkit/doc/latest/DevGuideRequestFactory.html" title="Getting Started with RequestFactory">RequestFactory</a>&nbsp;(as of this writing, the documentation hasn't yet been updated). Let's first see how to use it, and then how it works under the hood.</p>
<h2>RequestFactory at first sight</h2>
<p>I won't duplicate the existing documentation, so I'll highlight a few details that aren't there. But first, the basics!</p>
<p>Contrary to GWT-RPC which shares the same objects on the client and server side, RequestFactory uses <em>proxy</em> interfaces on the client-side (whose implementation is automatically generated). Thus, your real objects stay on the server, and are&nbsp;therefore not subject to the constraint of being translatable to JavaScript. That dychotomy also allows a single server-side domain object to be represented by different proxy interfaces on the client-side, each proxy exposing a different set of properties. The drawback is of course that there's a bit redundancy (having to re-declare methods on the client-side interface), but it brings flexibility, and removing the "must be translatable" constraint is enough to justify it. Finally, note that the same thing applies to services too, but it was already the case with GWT-RPC (with the RemoteService and *Async dychotomy, and the RemoteService interface vs. RemoteServiceServlet implementation).</p>
<p>So, you have services and domain objects on the server side, and service stubs and proxies on the client side, and you link your client-side interfaces with their server-side counterparts using annotations (@Service, @ServiceName, @ProxyFor and @ProxyForName).</p>
<p>To trigger the deferred binding generator, you group all service stubs in a factory interface (which extends RequestFactory) that you'll GWT.create(), and the code generator will walk the methods to find the service stubs, and then their methods to find the proxies, to finally generate their implementation and the necessary code to serialize them and communicate with the server.</p>
<p>On the server side, your service implementations and domain objects have almost no constraint. The client-side interface names go through the wire, so that RequestFactory can load them by name and find the annotations to find the server-side types. By default, service and domain objects have to be default-instantiable, domain objects must have a static method to load an instance by its identifier (the method has to be named findXxx, where Xxx is the name of the class), and service methods have to all be static (these were the constraints of RequestFactory in GWT 2.1.0), but we'll see later that GWT 2.1.1 allows you to remove them all.</p>
<h3>The undisclosed details</h3>
<p>The documentation is a bit short on details on how to really use RequestFactory. It has sample code, but not much explanation of what's going on.</p>
<p>For instance, you might have wondered why the service stubs have to extend an interface named RequestContext (and not something like ServiceStub or ServiceProxy)? Here's the reason: as its name suggests, a RequestContext collects changes to proxies and method invocations, until a fire() method is called. A RequestContext can be seen as a builder for a request made to the server, where you enqueue operations (changes made to proxies) and invocations that will then be replayed on the server, <em>translated</em>&nbsp;to apply on your domain objects and services. This is also why,&nbsp;each time you call a method on your factory object, you're given a new instance of your service stub.</p>
<p>Another key point is that when you're asked to retrieve a domain object from your datastore, you should use at most one instance of a given persisted object (e.g. if you're asked twice for the Person with identifier 1, you should return the same instance each time). This is <a href="http://code.google.com/p/google-web-toolkit/issues/detail?id=5389" title="Document that chained persistence in RequestFactory requires typical single EntityManager per request set up">causing</a> <a href="http://code.google.com/p/google-web-toolkit/issues/detail?id=5724" title="RequestFactory documentation regarding entity relationships is misleading">many </a><a href="http://code.google.com/p/google-web-toolkit/issues/detail?id=5776" title="Still can't access sub-entities in 2.1.1">incomprehensions</a>.</p>
<p>TODO: RequestContext instace as a collector for operations and invocations.</p>
<p>Now let's see&nbsp;<a href="http://googlewebtoolkit.blogspot.com/2010/12/gwt-211-is-now-available.html" title="GWT 2.1.1 is now available">what's new in 2.1.1</a>., paraphrasing what has been said in the announcement:</p>
<dl><dt>A service layer, which includes support for non-static service objects</dt> <dd>You can now give a class implementing ServiceLocator in the @Service annotation. That class will be instantiated by RequestFactory on the server-side (so it must be default-instantiable) and will be used as a provider of your service's instances. Using a locator, RequestFactory will now assume that your service methods are not static; it will get a service instance from your locator to call instance methods on it. A ServiceLocator is the perfect place to make use of Spring or Guice for dependency injection.</dd> <dt>Value object support</dt> <dd>EntityProxy are no longer the only type of proxies you can use on the client-side. GWT 2.1.1 adds the ValueProxy interface to represent value objects (this includes embedded objects &ndash;@Embedded in various ORM frameworks&ndash;). Contrary to EntityProxy, ValueProxy doesn't have the constraint to have a version and ID, and doesn't have a stableId(). ValueProxy allows for an easy migration path from GWT-RPC (if you don't use polymorphism, which RequestFactory still does not support).</dd> <dt>Multiple methods calls on a single request</dt> <dd>Actually, on a single RequestContext instance. You'll then send them in batch in a single HTTP request by calling the fire() method of the RequestContext, instead of the fire() method of a Request object returned by a method invocation. You can still have a Receiver per method invocation by using the to() method of Request. Actually, the fire() method of Request is a short-hand to calling the to() method and then immediately calling the fire() method of the RequestContext.</dd> </dl>
<p>&nbsp;</p>
