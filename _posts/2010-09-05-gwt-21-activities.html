---
layout: post
title: GWT 2.1 Activities
published: true
old_discuss_url: https://profiles.google.com/113945685385052458154/buzz/TDJR7kUJLYp
---
<p><strong>Updated 2010-10-16:</strong> updated to GWT 2.1.</p>
<p>GWT 2.1 activities sit on top of the <a href="{% post_url 2010-08-25-gwt-21-places %}" title="GWT 2.1 Places">GWT 2.1 places</a> to help in managing the place change events and navigation confirmation, and are part of what the GWT Team calls GWT's MVP Framework.</p>
<h2>The core concepts</h2>
<p>There are two main concepts in GWT 2.1 activities: <em>display regions</em> and <em>activities</em>. A display region is a part of the screen/page whose content changes in response to navigation. An activity is what the user <em>does</em> in a display region for a given place.</p>
<p>An important property of activities is that their lifetime is different from the one of the application (actually, from the display region, but those will generally have the same lifetime as the application, so&hellip;)</p>
<h2>Any in-the-wild example of those concepts?</h2>
<p>As an example, even though it's not made with GWT, let's look at GMail. Leaving alone ads, gadgets, and tasks for simplicity, the screen is divided into several parts:</p>
<ul>
<li>the top-level navigation menu (the menu with the &ldquo;Mail&rdquo;, &ldquo;Contacts&rdquo; and &ldquo;Tasks&rdquo; items)</li>
<li>the search bar</li>
<li>the navigation menu (on the left-hand side, below the top-level navigation menu)</li>
<li>the main region</li>
</ul>
<p>All of these are display regions, except the top-level navigation menu, as it has the same lifetime as the application (note that it listens to some events, probably place change events, to update the selected item, but it does not mean that it is or should be a display region and/or activity).</p>
<p>The search bar and navigation menu are very simple, as they just swaps activity when you switch between &ldquo;Mail&rdquo; and &ldquo;Contacts&rdquo;, whereas the main region constantly changes to contain the &ldquo;main activity&rdquo;: e.g. some list of mail conversations, a particular mail conversation, some list of contacts, or a particular contact's details.</p>
<h2>How those concepts map to classes in GWT?</h2>
<p>An activity in GWT can be any class implementing the <a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/activity/shared/Activity.html"><code>Activity</code></a> interface, whereas a display region is a class implementing the <a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/user/client/ui/AcceptsOneWidget.html"><code>AcceptsOneWidget</code></a>&nbsp;interface. Swapping activities in a display region in response to a place change event is the job of an <a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/activity/shared/ActivityManager.html"><code>ActivityManager</code></a>, which will ask an <a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/activity/shared/ActivityMapper.html"><code>ActivityMapper</code></a> the appropriate activity for the current place.</p>
<h2>Activity life-cycle, from the <code>ActivityManager</code> point of view</h2>
<p>When you navigate from one place to another, the current activity is first asked whether it <a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/activity/shared/Activity.html#mayStop()"><code>mayStop()</code></a>. This will eventually ask confirmation from the user before actually navigating (you'll probably recognize the <code>PlaceChangeRequestEvent</code> hidden behind this behavior).</p>
<p>If the navigation actually happens (i.e. the <code>PlaceChangeEvent</code> is fired), the current activity is first stopped (by a call to its <a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/activity/shared/Activity.html#onStop()"><code>onStop()</code></a> method) before the next activity can be started.</p>
<p>The next activity is given by the <code>ActivityMapper</code>, depending on the current place. It is then <a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/activity/shared/Activity.html#start(com.google.gwt.user.client.ui.AcceptsOneWidget, com.google.gwt.event.shared.EventBus)"><code>start()</code></a>ed within the <code>ActivityManager</code>'s managed display region (<code>AcceptsOneWidget</code>). When the activity is fully initialized, it asks back to be displayed, and we're done&hellip; until the next place change request.</p>
<p>Initialization of an activity can be asynchronous (usually tied to a GWT-RPC or RequestFactory request), which means that the user can change its mind before the activity is fully initialized and navigate to yet another place. In that case, the current activity is cancelled (by a call to its <a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/activity/shared/Activity.html#onCancel()"><code>onCancel()</code></a> method) instead of stopped. Note that in this case, it isn't previously asked whether it <code>mayStop()</code>, as it isn't fully started yet.</p>
<h2>Activity life-cycle, from the <code>Activity</code> point of view</h2>
<p>In response to navigation, the activity is asked to <code>start()</code>. It's passed the display region and the event bus. Initialization can be asynchronous, and when fully initialized, the activity calls the display region back with an <a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/user/client/ui/IsWidget.html"><code>IsWidget</code></a> object (i.e. an object capable of providing a Widget that displays it; note that the Widget base class implements IsWidget by returning itself, so you generally don't have to implement it yourself). The event bus is actually a <a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/event/shared/ResettableEventBus.html"><code>ResettableEventBus</code></a>, a wrapper around the application's global event bus, with the added property that any registered handler will automatically be unregistered when the activity is stopped, without it having to deal with <code>HandlerRegistration</code>s itself.</p>
<p>Once the activity has been started, and before it is fully initialized, it can be cancelled (by a call to its <code>onCancel</code> method) at any time if the user changes its mind and navigates to yet another place.</p>
<p>Otherwise (it's not been cancelled), when the user wants to navigate away, the activity will first be asked if it <code>mayStop()</code>, and will eventually be stopped (by a call to its <code>onStop()</code> method).</p>
<p>Note that because there can be several activities running concurrently (in different display regions), the activity might be stopped (or not) whichever the value it returned from the call to <code>mayStop()</code>. This is because a non-null return-value from <code>mayStop()</code> will only ask the user for confirmation, and null return-value won't overwrite a non-null value returned by another concurrently running activity (i.e. even if the activity returns null, another one might have returned a non-null value, asking the user for confirmation, and that one could finall have decided to stay at the current place). In other worlds, whichever the value you return from <code>mayStop()</code>, you shouldn't assume <code>onStop()</code> will or won't be called right away. However, <code>onStop()</code> won't ever be called without <code>mayStop()</code> being called first.</p>
<h2>Activity life-cycle, from the display region and user point of view</h2>
<p>The user interacts with the activities shown in display regions and isn't aware of this internal workflow. Stay concentrated as, because of the asynchronous nature of activities' startup, the notion of the current activity changes from the user's point of view!</p>
<p>In response to a user action (&ldquo;show this mail conversation&rdquo;, &ldquo;go back to inbox&rdquo;, etc.), the current activity has to be stopped and another started. As the next activity is starting (remember, this is already the current activity from the <code>ActivityManager</code>'s point of view), the current activity (previous one actually) is still displayed, but it's already <em>logically</em> stopped (its <code>onStop()</code> method has already been called). <em>Please note that this behavior will change in the next release: the display region's widget will be set to null as soon as the activity is stopped and until the next one is fully initialized.</em></p>
<p>It's your job as a developer to choose which behavior you want: the view is disabled, or it might trigger navigation.</p>
<p>Technically, it could still handle all user events but, because it's already stopped, it can be replaced at any given time and you won't have any notification (well, there's the widget's <code>onUnload()</code>, but anyway it's probably already too late to do anything useful). I'd therefore advise you to not do it, except to trigger navigation as it's about leaving the activity (which, you'll agree, doesn't conflicts with the already-stopped status of the activity).</p>
<p>The rule of thumb is thus to disable any action when an activity is stopped (i.e. from its <code>onStop()</code> method), except possibly navigation. It's up to you to decide whether this is done by disabling (graying out) widgets or just turning a deaf ear to their events.</p>
<h2>Hey, where's the MVP framework you talked about?</h2>
<p>Well, there's nothing forcing you to do MVP with GWT 2.1 activities, but it sure settles the basements for MVP: the <code>Activity</code> will be your presenter and the <code>IsWidget</code> you'll give back to the <code>AcceptsOneWidget</code>&nbsp;will be your view. And that's it. Really!</p>
<h2>A note about performance</h2>
<p>What takes most of the time in AJAX web apps on the client-side (i.e. with network and servers out of the equation) is manipulating the DOM. GWT 2.0 already gave us a wonderful tool to help us use the <code>HTMLPanel</code>, in the form of <code>UiBinder</code>, but it brings you nothing if you're constantly calling it. This means that your views should, when possible, be singletons. It doesn't imply though that your presenters should be!</p>
<p>If your presenters live longer than your activity (I mean from <code>start</code> to <code>onStop</code> here), they'll have to make sure they correctly clean up their internal state each time they're recycled. Because presenters are POJOs, they are actually quite lightweight, and the idea is that the cost for you to ensure the state is correctly cleaned up between uses of a singleton object outweighs the negligible performance lost induced by using many short-lived objects.</p>
<p>This works best if you listen to user events by registering a presenter delegate to your view: you'll call <code>view.setDelegate(this)</code> from <code>start</code> and <code>view.setDelegate(null)</code> from <code>onStop</code>. For your app to properly work, you only have to ensure that you don't try to use two presenters simultaneously with the same view, but it'll actually come naturally in most cases, and is really no different from ensuring a singleton presenter isn't used twice at a given time.</p>
<h2>Conclusion</h2>
<p>You're now ready to start coding wonderful applications, using a simple yet powerful approach to navigation handling, which integrates nicely with MVP.</p>
