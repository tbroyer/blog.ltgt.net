---
layout: post
title: Using Protobuf client-side with GWT
published: true
---
<p><em>This is a follow-up post to <a href="{% post_url 2010-04-02-exploring-using-protobuf-in-the-browser %}">Exploring using Protobuf in the browser</a>.</em></p>
<p>There are many different approaches to using <a href="http://code.google.com/apis/protocolbuffers/">Protocol Buffers</a> with <a href="http://code.google.com/webtoolkit/">GWT</a>, both for messages and services.</p>
<h2>The Message API</h2>
<p>Each language supported <em>natively</em>&nbsp;by protoc (C++, Python and Java) has a different API for Messages:</p>
<ul>
<li>Java uses a builder approach: each message class has a corresponding builder class; the builder instance can only be used once, to initialize a single message instance; only the builder is mutable, a message instance is always immutable.</li>
<li>In Python, a message instance is always mutable.</li>
<li>C++ follows the same approach as Python but takes advantage of the <code>const</code> keyword to eventually <a href="http://en.wikipedia.org/wiki/Const-correctness"><em>freeze</em> an object</a>, so if a field's type is a message (or string), you have to explicitly ask for a mutable <span style="text-decoration: underline;">or</span> immutable instance.</li>
</ul>
<p>These differences are guided by each language's features: C++ can contextually make an object immutable, Java cannot but a builder can easily be given access to the message internals, and finally Python is all about <em>unlocked</em> access to objects, even their internals (while this has changed a bit in recent versions).</p>
<p>Closure Library, because JavaScript has similar features as Python, uses the same approach of always mutable message instances.</p>
<p>GWT is both in the Java and the JavaScript lands, but because it <em>looks like</em> Java, I'd rather go with the same API as the <em>native</em> Protobuf Java API. I'd even use the exact same package and class names and take advantage of GWT's <em>emulation</em> feature (see <a href="http://code.google.com/webtoolkit/doc/latest/DevGuideOrganizingProjects.html#DevGuideModuleXml"><em>Overriding one package implementation with another</em></a>) to only implement the subset of the API that's translatable to JavaScript (i.e. everything that doesn't involve <a href="http://java.io"><code>java.io</code></a>). Moreover, using this approach, because the developer never actually sees the emulation code, the message and builders could eventually be the very same object, possibly a lightweight <a href="http://code.google.com/webtoolkit/doc/latest/DevGuideCodingBasicsOverlay.html">JavaScript Overlay Type</a> (this of course would have implications on <code>instanceof</code> results). Using overlay types though would make it impossible to implement the Message.getDescriptor() method, limiting the API to the subset of MessageLite (but using <code>optimize_for = LITE_RUNTIME</code> <a href="http://code.google.com/p/protobuf/issues/detail?id=174">rules out defining services</a>)</p>
<h2>Message serialization</h2>
<p>In addition to being an IDL with code generators, Protobuf is also an efficient, "language-neutral, platform-neutral, extensible mechanism for serializing structured data". However, due to limitations of browser APIs, the binary format wouldn't be usable (or with a considerable overhead). The structured format that works the best in the browser is undoubtedly JSON, and GWT implementation of Protobuf couldn't be complete without built-in JSON ser/deserialization (and using insertion points, protoc code generator plugins can easily add the same toJSON/parse/mergeFrom APIs on the server-side too.</p>
<p>With GWT however, there's another serialization format: the one used by <a href="http://code.google.com/webtoolkit/doc/latest/DevGuideServerCommunication.html#DevGuideRemoteProcedureCalls">GWT RPC</a>. I said <a href="{% post_url 2010-04-02-exploring-using-protobuf-in-the-browser %}">previously</a> that GWT RPC tightly couples the client and server codebase and would make it impossible to extend messages without deploying them in one go. This isn't completely true though: GWT RPC <em>versions</em> classes based on their fully-qualified name, the fully-qualified name of parent classes, and the name of each of these classes' fields; but when you use a custom field serializer, the serializer class is used instead, which generally doesn't have fields or parent class (as its methods have to be static). This means that such a serializer could very well implement its own "error recovery" algorithm to ignore unknown fields (and narrow-cast numbers, so that a field's type could be changed from e.g. byte to int without fearing exceptions, similar to how Protobuf's binary format works; the exception here would be longs, as they are emulated as a pair of doubles in GWT).</p>
<h2>The RPC services</h2>
<p>Starting with version 2.3.0, Protobuf warns against using the <a href="http://code.google.com/apis/protocolbuffers/docs/reference/java-generated.html#service">generic services API</a> but instead use plugins to generate code specific to your RPC implementation. GWT has a pretty good RPC-over-HTTP implementation, so it'd probably be the best fit (even though I believe the generic API could be implemented on the client side, with an overhead comparable to GWT RPC, maybe even smaller if you serialize to/from JSON and keep the deserialized object as-is, in which case the native JSON.parse/stringify browser implementations could be used).</p>
<p>But actually, whichever the chosen API, the underlying implementation could be the other one; i.e. it's possible to implement Protobuf's generic services API on top the GWT RPC protocol, or the GWT RPC API on top of some some other serialization such as JSON (as already done in <a href="http://code.google.com/p/gwt-rpc-plus/">gwt-rpc-plus</a>).</p>
<p>The major drawback with Protobuf's generic services API is that it relies on Protobuf reflexivity, and removing it from the API would actually make it too different from the original one to justify using it (what would be an <a href="http://code.google.com/apis/protocolbuffers/docs/reference/java/com/google/protobuf/RpcChannel.html">RpcChannel</a> without MethodDescriptor?)</p>
<h2>Where to go now?</h2>
<p>Well, experiment? And make compromises: Is the full <a href="http://code.google.com/apis/protocolbuffers/docs/reference/java/com/google/protobuf/Message.html">Message</a> API worth it if you could have a much lighter-weight implementation of <a href="http://code.google.com/apis/protocolbuffers/docs/reference/java/com/google/protobuf/MessageLite.html">MessageLite</a> based on JavaScript Overlay Types? Is <code>instanceof</code> support a must-have? Should <a href="http://code.google.com/apis/protocolbuffers/docs/proto.html#extensions">extensions</a> be supported? Would it be a problem if the emulation of the Protobuf library used interfaces in place of the original classes in some cases? (it would allow the emulated message and builder be the same class)</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
