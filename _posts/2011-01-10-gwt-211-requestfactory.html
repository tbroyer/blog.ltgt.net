---
layout: post
title: GWT 2.1.1 RequestFactory
published: true
---
<p><strong>Updated 2011-02-10:</strong> I was wrong about optimistic locking. It was there in early versions of RequestFactory but never shipped in <em>GA</em> releases.</p>
<p><a href="http://code.google.com/webtoolkit/doc/latest/DevGuideRequestFactory.html" title="Getting Started with RequestFactory">RequestFactory</a> was already available in GWT 2.1 but really becomes <em>usable</em> starting with GWT 2.1.1.</p>
<p>RequestFactory is "<em>an alternative to GWT-RPC for creating data-oriented services</em>." It's been initially designed for <a href="http://en.wikipedia.org/wiki/CRUD_(acronym)">CRUD</a> on entities (domain objects with an identifier and version), but as of GWT 2.1.1 can actually also be used as a general-purpose RPC mechanism.</p>
<h2>The Basics</h2>
<p>With RequestFactory, you have a set of domain objects and services on the server-side, and proxy and stub interfaces on the client-side, using annotations and naming conventions to map ones to the others. Note that a single server-side object can have several different mappings on the client-side.</p>
<p>Whichever layout you have on the server-side, RequestFactory clearly separates domain objects (that only have properties) from services (methods acting on those objects) on the client-side: there's not necessarily a <em>1:1</em> mapping between your client-side proxies and service stub interfaces and your server-side domain objects and services.</p>
<p>As you could have guess from the above, RequestFactory makes extensive use of code generation: all you have on your client code are interfaces, whose implementations will entirely be generated when compiling your application from Java to JavaScript.</p>
<h2>Domain objects</h2>
<p>There are two kind of domain objects: entities and value objects. The difference is that entities have an identifier (and RequestFactory also mandates that they have a version, more on this later), and then RequestFactory can be used to <em>update</em> an existing object; while value objects are just that: values with properties, with no particular <em>identity</em>. Each one maps to a distinct base interface on the client-side: <a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/requestfactory/shared/EntityProxy.html"><code>EntityProxy</code></a> and <a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/requestfactory/shared/ValueProxy.html"><code>ValueProxy</code></a>, respectively. Apart from that, all a (client-side) proxy is allowed to have are property accessors (getters and setters).</p>
<p>The crux of RequestFactory, compared to classical RPC, are entities. On the client-side, RequestFactory will <em>monitor</em> your calls to property setters and only send a <em>diff</em> to the server, where the setters will be re-applied. This is why having an identifier and version are so important: the identifier allows RequestFactory to load the object so it can apply the <em>diff</em> to it, and the version is used to detect changes and fire update events (see below). When working with objects having many properties, and/or with many such objecs, this can significantly reduce the amount of data that goes over the wire (which also means RequestFactory is well-suite for mobile devices), while on the other hand, value objects are always sent with all their properties. Last, but not least, <a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/requestfactory/shared/EntityProxyChange.html">events</a> will be dispatched on the client-side each time a domain object is <a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/requestfactory/shared/WriteOperation.html#PERSIST">persisted</a>, <a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/requestfactory/shared/WriteOperation.html#UPDATE">updated</a> or <a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/requestfactory/shared/WriteOperation.html#DELETE">deleted</a> on the server (it obviously only concerns entities, not value objects, and only those that have been sent in or returned from a given request).</p>
<h2>Services</h2>
<p>Services are methods. A method can take as argument and/or return domain objects (entities or value objects) or simple values. Most common such methods are those that implement CRUD on entities, but if you only use value objects and simple values you have a general-purpose RPC mechanism.</p>
<p>RequestFactory supports many use cases, as a service method can be (on the server-side) either a static method, an instance method on a service object, or an instance method on a domain object.</p>
<h2>Putting it all together</h2>
<p>Keep in mind that RequestFactory makes use of code generation, so you'll always start (in your client code) by <code>GWT.create()</code>ing a class, or rather in this case, an interface. This interface has to extend <code>RequestFactory</code>, and define no-args methods that return service stubs. Those method are factories: each call will return a new instance (hence the name of the interface: <code>Request<strong>Factory</strong></code>).</p>
<p>A service stub is an interface extending <a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/requestfactory/shared/RequestContext.html"><code>RequestContext</code></a> and defining service methods. The interface has to be annotated with <code>@<a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/requestfactory/shared/Service.html">Service</a></code> or <code>@<a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/requestfactory/shared/ServiceName.html">ServiceName</a></code> to map it to a server-side class. Those service methods have the same signature as their server-side counter-part, with the exception of the return type: it will be either <code><a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/requestfactory/shared/Request.html">Request</a>&lt;T&gt;</code> if the method lives in the server-side class referenced by the <code>@Service</code>/<code>@ServiceName</code> annotation, or an <code><a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/requestfactory/shared/InstanceRequest.html">InstanceRequest</a>&lt;P,T&gt;</code> if the method is on a domain object (of the type mapped to<code>P</code> on the server-side). In any case, the <code>T</code> type is the actual return type of the method. If you have instance methods on the server-side service object, you have to provide a <a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/requestfactory/shared/ServiceLocator.html"><code>ServiceLocator</code></a> class in the <code>@Service</code>/<code>@ServiceName</code> annotation; RequestFactory will instantiate that class to then ask it for an intance of the service class; otherwise, all methods declared as <code>Request&lt;T&gt;</code> will have to be static methods on the server-side class. As for the difference between <code>@Service</code> and <code>@ServiceName</code>, the former uses class literals that have to be available at compile-time while the latter uses class names; if you use the <code>@Service</code> interface, the <code>RequestFactoryGenerator</code> will automatically validate that the declared client-side methods actually map to existing server-side methods.</p>
<p>The <code>RequestFactoryGenerator</code> has found the service stub interfaces by examining the methods of the <code>RequestFactory</code> root interface, and it'll similarly find the domain objects' proxy interfaces looking at the arguments and return types of the service methods.</p>
<p>A proxy is an interface that extends either <a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/requestfactory/shared/EntityProxy.html"><code>EntityProxy</code></a> for an entity, or <a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/requestfactory/shared/ValueProxy.html"><code>ValueProxy</code></a> for a value object, and define accessors for the object's properties (you don't have to provide a getter/setter pair for each property, you can have a getter without a setter; you however cannot have a setter without an associated getter). The interface has to be annotated with <code>@<a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/requestfactory/shared/ProxyFor.html">ProxyFor</a></code> or <code>@<a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/requestfactory/shared/ProxyForName.html">ProxyForName</a></code> to map it to a server-side class (and similarly, the <code>RequestFactoryGenerator</code> will validate at compile-time that declared property accessors actually map to existing server-side peers if you use the <code>@ProxyFor</code> annotation, but won't if you use the <code>@ProxyForName</code>).</p>
<p>For entities, RequestFactory will have to load them by their identifier (so it can apply the <em>diffs</em> sent from the client before landing them to the service methods). To do so, it will either ask a <a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/requestfactory/shared/Locator.html"><code>Locator</code></a> (that it will first instantiate, of course) or fallback to using a static method named <code>findXxx</code> (where <code>Xxx</code> is the name of the entity class). The <code>Locator</code> will also provide the entity's identifier and version, defaulting <code>getId</code> and <code>getVersion</code> accessors respectively.</p>
<p>All those interfaces have to be available to your client code, and also compiled and deployed to your server, as RequestFactory will need the <code>@Service</code>, <code>@ProxyFor</code> et al. at runtime (also note that the validation that is performed at compile-time if you use @Service and <code>@ProxyFor</code> will be done at runtime with all four annotations). For this reason, they're often placed in a sub-package called shared.</p>
<h2>OK, but how to use it now?</h2>
<p>The first thing to do is to declare a servlet mapping for the <a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/requestfactory/server/RequestFactoryServlet.html"><code>RequestFactoryServlet</code></a> at path <code>/gwtRequest</code> (this is the default, it can be changed). That's all you have to do on the server side.</p>
<p>On the client side, you'll start by <code>GWT.create()</code>ing your <code>RequestFactory</code> root interface, and then immediately <a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/requestfactory/shared/RequestFactory.html#initialize(com.google.gwt.event.shared.EventBus)"><code>initialize()</code></a> it before you can use it. The <code>initialize()</code> method expects an <code>EventBus</code> where the <code>EntityProxyChange</code> events will be dispatched, and an optional <a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/requestfactory/shared/RequestTransport.html"><code>RequestTransport</code></a>. If the <code>RequestTransport</code> is omitted, a <a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/requestfactory/client/DefaultRequestTransport.html"><code>DefaultTransport</code></a> will be used, with the default servlet path of <code>GWT.getHostPageBaseURL() + "gwtServlet"</code> (in other words, this is where you have a chance of changing those default values).</p>
<p>Next you'll create a <code>RequestContext</code> (service stub) by calling one of the methods you defined on the <code>RequestFactory</code> root interface. As for the <code>RequestFactory</code> interface, the name <code>RequestContext</code> is not innocent: a <code>RequestContext</code> is a kind of builder for your request, this is where you'll queue entity property setters and service method calls. It represents the context in which things are done before you send them all in one bach request to the server.</p>
<p>On that context, as I said above, you'll be able to queue entity property setter calls. For that, you first have to <a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/requestfactory/shared/RequestContext.html#edit(T)"><code>edit()</code></a> a proxy, as these are immutable by default (this holds true for value objects too, even though their property setters are not <em>monitored</em> like entities' ones). A proxy can only be edited by one <code>RequestContext</code> at a time; it however doesn't matter how many time you call <code>edit()</code> on the same proxy. Note that <code>edit()</code> doesn't update the given proxy in-place, it instead returns a new object. If you want to create a new proxy instead of editing an existing one, you can use the <code>RequestContext</code>'s <a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/requestfactory/shared/RequestContext.html#create(java.lang.Class)"><code>create()</code></a> method. The returned object is mutable so you don't have to <code>edit()</code> it before you modify it.</p>
<p>You'll also be able to queue service method calls. To do that, you'll simply call the method on the service stub, passing the appropriate arguments. If you're calling an <code>InstanceRequest&lt;P,T&gt;</code>, you'll also have to call <a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/requestfactory/shared/InstanceRequest.html#using(P)">using()</a> on the returned <code>InstanceRequest</code> to provide the object instance on which to call the method. You can further refine the invocation using the <a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/requestfactory/shared/Request.html#with(java.lang.String...)"><code>with()</code></a> method which controls which properties of the returned entities will be sent back to the client (this helps reduce the response payload size), and the <a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/requestfactory/shared/Request.html#to(com.google.gwt.requestfactory.shared.Receiver)"><code>to()</code></a> method where you'll give a <code><a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/requestfactory/shared/Receiver.html">Receiver</a>&lt;T&gt;</code> to actually receive the method's returned value.</p>
<p>When you're done setting up your <code>RequestContext</code>, you'll <a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/requestfactory/shared/RequestContext.html#fire()"><code>fire()</code></a> it to actually send everything to the server. One thing to remember is that whichever the order you called them, <em>operations</em> (property setter calls on entity proxies) will always be processed before <em>invocations</em> (service method calls). This means you can <code>create()</code> an object, <code>save()</code> it right away and then starts modifying it; when processed on the server, the object will first be <em>applied its setters</em>, then the <code>save()</code> method will be called. However, the relative order of operations and invocations is respected (i.e. if you call <code>setFoo</code> before <code>setBar</code>, then <code>setFoo</code> will be applied before setBar on the server too; and similarly for service method calls).</p>
<p>You can pass a <code>Receiver&lt;Void&gt;</code> to the <code>RequestContext.fire()</code> method, and it will be called after the <code>Receiver</code>s for each service method invocation. Note however that its <code>onFailure</code> will be called only in case of <em>general failure</em>, so in most case only its <code>onSuccess</code> method will be called, whether the distinct invocations are successful or not.</p>
<p>As a shortcut, you can also call a <code>fire()</code> directly on a <code>Request</code> object; and passing a <code>Receiver</code> to the <code>fire()</code> method is equivalent to calling <code>to()</code> and <code>fire()</code> sequentially. I'd only recommend doing this if you have only a single <em>invocation</em> in your <code>RequestContext</code>, though.</p>
<h2>What's next?</h2>
<p>In the following article(s), I'll deal with the changes between GWT 2.1.0 and 2.1.1, how RequestFactory compares to GWT-RPC, JSR 303 validation, integration with the <a href="http://code.google.com/webtoolkit/doc/latest/DevGuideUiEditors.html">GWT Editor framework</a>, <code>ServiceLayerDecorator</code>s (or how to tweak the server-side processing, for example to integrate nicely with Guice or Spring) and other advanced techniques.</p>
