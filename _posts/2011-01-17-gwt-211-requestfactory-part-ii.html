---
layout: post
title: GWT 2.1.1 RequestFactory â€“ Part II
published: true
discuss_url: https://profiles.google.com/113945685385052458154/buzz/CRjHNcmZnk7
---
<p>Last week, I posted a first article on <a href="{% post_url 2011-01-10-gwt-211-requestfactory %}">GWT 2.1.1 RequestFactory</a>, followed a few days later by one on <a href="{% post_url 2011-01-14-gwt-21-editors %}">GWT 2.1 Editors</a> (and, as promised in the former, how to use them with RequestFactory). In this article, I'll deal with 3 topics I also promised to tackle: what changed since 2.1.0, how does RequestFactory compares to GWT-RPC, and finally how does it integrates with JSR-303 Bean Validation (feel free to jump directly your section of interest). But first, let's start with something I forgot to talk about in my previous article!</p>
<h2>Chained persistence</h2>
<p>When you're asked to retrieve a domain object from your datastore, you should use at most one instance of a given persisted object (e.g. if you're asked twice for the Person with identifier 1, you should return the same instance each time, or at least instances that live in the same <em>context</em> so that changes to one instance will be persisted when saving another instance representing the same entity). This is <a href="http://code.google.com/p/google-web-toolkit/issues/detail?id=5389" title="Document that chained persistence in RequestFactory requires typical single EntityManager per request set up">causing</a> <a href="http://code.google.com/p/google-web-toolkit/issues/detail?id=5724" title="RequestFactory documentation regarding entity relationships is misleading">many</a> <a href="http://code.google.com/p/google-web-toolkit/issues/detail?id=5776" title="Still can't access sub-entities in 2.1.1">incomprehensions</a>. Fortunately, when using JPA or JDO, it's as easy as using a request-scoped transaction.</p>
<h2>What's new in 2.1.1</h2>
<p>RequestFactory saw its first stable release in GWT 2.1.0. In GWT 2.1.1, the server part was totally rewritten, and the client side was slightly reworked as well. But this is all transparent to the developer, and code that compiled and ran with GWT 2.1.0 should still work with GWT 2.1.1. The following will probably only be useful for people who started using RequestFactory in 2.1.0 and want to know which new things can benefit them.</p>
<p>Features GWT 2.1.1 provides are summed up in the <a href="http://googlewebtoolkit.blogspot.com/2010/12/gwt-211-is-now-available.html" title="GWT 2.1.1 is now available">release announcement</a>:</p>
<ul>
<li><em>"A service layer, which includes support for non-static service objects"</em>: GWT 2.1.1 introduced the <code>Locator</code> and <code>ServiceLocator</code> interfaces, which allow you to, respectively, get rid of the <code>findXxx</code> static method on entities (along with providing ID and version without necessarily using thus-named domain object properties), and instantiate a service class to be able to use instance methods for services.</li>
<li><em>"EntityProxy are no longer the only type of proxies you can use on the client-side"</em>: GWT 2.1.1 adds the <code>ValueProxy</code> interface (and the <code>BaseProxy</code> interface that's a common parent for both <code>EntityProxy</code> and <code>ValueProxy</code>).</li>
<li><em>"Multiple methods calls on a single request"</em>: in GWT 2.1.0 you could only have a single invocation on a give <code>RequestContext</code> before you <code>fire()</code> it. This limitation has simply been removed.</li>
</ul>
<h2>How does RequestFactory compare to GWT-RPC</h2>
<p>Contrary to <a href="http://code.google.com/webtoolkit/doc/latest/DevGuideServerCommunication.html#DevGuideRemoteProcedureCalls">GWT-RPC</a> which shares the same objects on the client and server side, RequestFactory uses proxy interfaces on the client-side (whose implementation is automatically generated). Thus, your real objects stay on the server, and are therefore not subject to the constraint of being translatable to JavaScript (remember having to fight with <a href="http://code.google.com/intl/fr-FR/webtoolkit/articles/using_gwt_with_hibernate.html" title="Using GWT with Hibernate">Hibernate's enhanced collections and lazy-loading</a> until <a href="http://hibernate4gwt.sourceforge.net/hibernate_gwt_problem.html" title="The Hibernate-GWT problem">hibernate4gwt</a> and <a href="http://noon.gilead.free.fr/gilead/index.php?page=presentation">gilead</a>?). That dychotomy also allows a single server-side domain object to be represented by different proxy interfaces on the client-side, each proxy exposing a different set of properties.</p>
<p>The drawback is of course that there's a bit of redundancy (having to re-declare methods on the client-side interface), but on the other hand it brings flexibility and, if you ask me, removing the "must be translatable" constraint is enough to justify it.</p>
<p>It's worth mentionning that the dichotomy actually already existed in GWT-RPC in the service interfaces (synchronous, implemented by your <code>RemoteServiceServlet</code>, and asynchronous, used on the client-side).</p>
<p>Despite removing the "must be translatable" constraint, RequestFactory comes with a number of limitations regarding the types that can be transported: only primitive types and their boxed classes, enums, strings, dates (<code>java.util.Date</code>), <code>BigInteger</code> and <code>BigDecimal</code>, other proxies, and finally <code>java.util.List</code> and <code>java.util.Set</code> of any of the above, can be used. RequestFactory doesn't (<a href="http://code.google.com/p/google-web-toolkit/issues/detail?id=5367" title="Issue 5367: Polymorphism not supported by Request Factory">yet!</a>) support polymorphism (which means you have to use the exact classes I listed above; you cannot for instance declare a property of type <code>java.util.SortedSet</code> or <a href="http://code.google.com/p/google-web-toolkit/issues/detail?id=5817" title="Issue 5817: RequestFactory does not support java.sql.Timestamp"><code>java.sql.Timestamp</code></a>).</p>
<p>However, because of those limitations, RequestFactory does not use serialization policies computed at compile-time, which means that your client and server code are much more loosely coupled than with GWT-RPC. With RequestFactory, provided the changes were made in a <em>compatible way</em>, you can independently deploy your client and server code, including using DevMode in <code>-noserver</code> mode against an already deployed application.</p>
<p>Actually, RequestFactory has all the advantages of <a href="http://code.google.com/webtoolkit/doc/latest/DevGuideServerCommunication.html#DevGuideDeRPC" title="Direct-Eval RPC">De-RPC</a>:</p>
<ul>
<li>the protocol is JSON-based, which makes deserialization very fast on the browser.</li>
<li>client and server can use slightly different (but <em>compatible</em>) objects and still communicate (this was probably inspired by <a href="http://code.google.com/apis/protocolbuffers/docs/proto.html#updating">Protocol Buffers</a>), which helps with hot-deployment.</li>
<li>you don't have to compile and deploy your app each time you change a service or domain object to be able to debug using DevMode in the <code>-noserver</code> case.</li>
</ul>
<p>&hellip;and it works on Google AppEngine.</p>
<p>Finally, although the API and concepts are highly different, RequestFactory and its new (in 2.1.1) support for <code>ValueProxy</code> makes it possible to use it as a general-purpose RPC mechanism, at least to aid in migrating from GWT-RPC, and it's expected that De-RPC will die in favor of RequestFactory (don't worry, GWT-RPC will still be supported, we're only talking here about De-RPC, which never leaved the <em>experimental</em> state).</p>
<h2>JSR-303 Bean Validation</h2>
<p>When receiving a request to process, the <code>RequestFactoryServlet</code> applies the <em>operations</em> on the domain objects and validates them before processing any <em>invocation</em>. The default behavior for that validation is to use <code>javax.validation</code>, and that's why you might see an "<code>Unable to initialize a JSR 303 Bean Validator</code>" error in your server logs if you do not have a JSR 303 implementation (such as <a href="http://www.hibernate.org/subprojects/validator.html" title="Hibernate Validator - Bean Validation reference implementation">Hibernate Validator</a>) in your classpath, and why you must have the validation API in your classpath for RequestFactory to work, to begin with.</p>
<p><a href="http://docs.jboss.org/hibernate/stable/beanvalidation/api/javax/validation/ConstraintViolation.html"><code>ConstraintViolation</code></a>s are reported on the client side as a set of <a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/requestfactory/shared/Violation.html"><code>Violation</code></a>s to the <a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/requestfactory/shared/Receiver.html#onViolation(java.util.Set)"><code>onViolation()</code></a> method of <a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/requestfactory/shared/Receiver.html"><code>Receiver</code></a>s. Because validation is done before <em>invocations</em> are processed, all <code>Receiver</code>s for a given <a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/requestfactory/shared/RequestContext.html"><code>RequestContext</code></a> will receive the violations, and the default implementation of <code>onViolation()</code> is to call <a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/requestfactory/shared/Receiver.html#onFailure(com.google.gwt.requestfactory.shared.ServerFailure)"><code>onFailure()</code></a> with a fatal <a href="http://google-web-toolkit.googlecode.com/svn/javadoc/2.1/com/google/gwt/requestfactory/shared/ServerFailure.html"><code>ServerFailure</code></a>, which will by result in a <code>RuntimeException</code>.</p>
<h2>What's next?</h2>
<p>In the next article, I expect to write about the <code>ServiceLayerDecorator</code>s, that is, the internals of the <code>RequestFactoryServlet</code>, where you can plug your own code to tweak a few things.</p>
